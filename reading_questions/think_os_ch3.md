# ThinkOS Ch3 Reading Questions

### Virtual memory

1) The Georgian alphabet has 33 letters.  How many bit are needed to specify a letter?

2^5 is 32, so 6 bits would be required to represent 33 letters.

2) In the UTF-16 character encoding, the binary representation of a character can take up to 32 bits.  
Ignoring the details of the encoding scheme, how many different characters can be represented?

2^32 is 4294967296, so 32 bits can represent up to 4294967296 characters.

3) What is the difference between "memory" and "storage" as defined in Think OS?

Storage refers to HDDs and SSDs, which are the drives that store files.  Main memory, RAM in most instances, stores the data for running processes.

4) What is the difference between a GiB and a GB?  What is the percentage difference in their sizes?

GiB is the abbreviation for a gibibyte, or 2^30 bytes.  GB is a gigabyte, which is 10^9 bytes.  Their us an approximately 7% difference in their values.

5) How does the virtual memory system help isolate processes from each other?

Virtual memory is utilized when virtual memory addresses are generated by a program.  These virtual addresses amp to physical memory addresses that are read and written.  Because one process is not able to generate the same virtual addresses as another process, there are no memory locations in danger of being accessed by more than one process.

6) Why do you think the stack and the heap are usually located at opposite ends of the address space?

Since they're located at opposite ends, they can each grow and shrink without changing any of the addresses of the other.

7) What Python data structure would you use to represent a sparse array?

Dictionary

8) What is a context switch?

A context switch occurs when a process is interrupted to run a different process.  The state of the first process must be saved, so there are multiple page tables in the MMU at a given time, usually identified by their process ID.


In this directory, you should find a subdirectory named `aspace` that contains `aspace.c`.  Run it on your computer and compare your results to mine.
  
1) Add a second call to `malloc` and check whether the heap on your system grows up (toward larger addresses).  

The address of the original variable p converted to decimal was 11239440, and the new variable q is at 11239584.  The heap grew up.

2) Add a function that prints the address of a local variable, and check whether the stack grows down.  

The address of main converted to decimal is 4195855, and printLocal is at 4195798.  The stack grew down.

3) Choose a random number between 1 and 32, and allocate two chunks with that size.  
How much space is there between them?  Hint: Google knows how to subtract hexadecimal numbers.

The difference between the two addresses of the allocated space was 0x20, or 32 in decimal.